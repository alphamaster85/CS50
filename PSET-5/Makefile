#
# Makefile
#
# Computer Science 50
# Problem Set 5
#


# Рядок нижче визначає змінну на ім’я CC яка показує що make має використовувати clang для компіляції.
CC = clang

# Наступний рядок визначає змінну CFLAGS, яка визначає прапори,  які має використати clang, більшість з них повинні бути вам знайомі.
CFLAGS = -ggdb3 -O0 -Qunused-arguments -std=c99 -Wall -Werror

# Наступний рядок визначає змінну EXE, значення якої буде ім’ям нашої програми.
EXE = speller

# Цей рядок визначає змінну HDRS, значення якої – список заголовних файлів використовуваних speller-ом, розділений пробілами.
HDRS = dictionary.h

# Наступний рядок визначає змінну LIBS, значення якої – розділений пробілами список заголовних бібліотек,
# кожній з яких має передувати -l (Пригадайте використання -lcs50 раніше.)
# Швидше за все вам не буде потрібна жодна бібліотека для цього завдання, але ми включили цю опцію про всяк випадок.
LIBS =

# Даний рядок визначає змінну SRCS значення якої – розділений пробілами список С-файлів, які є реалізацією перевірки правопису.
SRCS = speller.c dictionary.c

# Наступний рядок визначає змінну OBJS, значення якої те саме, що і SRCS, за винятком того, що розширення файлів не .c, а .o.
OBJS = $(SRCS:.c=.o)

# Рядок нижче визначає «ціль», використовуючи змінні, що ми визначили вище, яка визначає як make буде компілювати програму.
$(EXE): $(OBJS) $(HDRS) Makefile
	$(CC) $(CFLAGS) -o $@ $(OBJS) $(LIBS)

# Наступний рядок визначає, що наші .o файли залежать від dictionary.h і Makefile, тому зміни будь-якого з них приведуть
# до рекомпіляції .o файлів при наступному запуску make.
$(OBJS): $(HDRS) Makefile

# Нарешті даний код визначає іншу ціль для очищення директорії.
clean:
	rm -f core $(EXE) *.o
